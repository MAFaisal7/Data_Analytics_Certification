library(dplyr)
library(forecast)
install.packages("forecast")
library(forecast)
library(forecast)
install.packages("forecast")
library(forecast)
library(curl)
install.packages("curl")
library(curl)
install.packages("forecast")
library(forecast)
library(dplyr)
library(readxl)
library(forecast)
library(ggplot2)
installed.packages("readxl")
a <- c("970101","901116","500220")
substr(a,1,2)
as.numeric(substr(a,1,2))
118-as.numeric(substr(a,1,2))
min(as.numeric(substr(a,1,2)))
b <- c("zaid","bilal","usama","zaid")
duplicated(b)
duplicated.array(b)
duplicated.data.frame(b)
duplicated.data.frame(as.data.frame(b))
?duplicated
x <- "zaaidd"
length(unique(x))
unique(x)
x <- as.character("zaaidd")
unique(x)
uniqchars <- function(x) unique(strsplit(x, "")[[1]])
uniqchars(x)
strsplit(x,"")
x <- "zaaidd bilal"
x <- "zaaiddb bilal"
strsplit(x,"")
uniqchars(x)
x[1]
x
?grep
x <- "zaaiddb @bilal"
grep("[a-z]",x)
grepl("[a-z]",x)
grep("[a-z]",x)
v <- strsplit(x,"")
length(v)
v
v <- strsplit(x,"")[[1]]
unique(c)
unique(v)
gsub("[[:punct:]]", " ", x)
:punct:
gsub("[[:punct:]]", "", x)
x
gsub("[^[:alnum:]]", "", x)
uniqchars <- function(x){
uniqchars <- function(x){
uniqchars <- function(x){
x <- gsub("[^[:alnum:]]", "", x)
return (length(unique(strsplit(x, "")[[1]]))
}
uniqchars <- function(x){
x <- gsub("[^[:alnum:]]", "", x)
return (length(unique(strsplit(x, "")[[1]]))
}
uniqchars <- function(x)
{
x <- gsub("[^[:alnum:]]", "", x)
return (length(unique(strsplit(x, "")[[1]])))
}
x <- "zaaiddb @bilal"
uniqchars(x)
uniqchars <- function(x)
{
x <- gsub("[^[:alnum:]]", "", x)
print (x)
return (length(unique(strsplit(x, "")[[1]])))
}
uniqchars(x)
v <- c("zaid@gmail.com","aaaa@aaa.com")
uniqchars(v)
uniqchars("zaid@gmail.com")
uniqchars("aaa@aaa.com")
unique("zaid@gmail.com")
uniqchars <- function(x)
{
x <- gsub("[^[:alnum:]]", "", x)
print (type(x))
return (length(unique(strsplit(x, "")[[1]])))
}
v <- c("zaid@gmail.com","aaaa@aaa.com")
uniqchars(v)
uniqchars <- function(x)
{
x <- gsub("[^[:alnum:]]", "", x)
print (class(x))
return (length(unique(strsplit(x, "")[[1]])))
}
uniqchars(v)
y <- gsub("[^[:alnum:]]", "", v)
y
length(unique(strsplit(y, "")[[1]]))
length(unique(strsplit(y[1], "")[[1]]))
length(unique(strsplit(y[2], "")[[1]]))
length(unique(strsplit(y[2], "")))
length(unique(strsplit(y, "")))
strsplit(y)
strsplit(y,"")
unique(strsplit(y,""))
strsplit(y,"")[1]
strsplit(y,"")[[]][1]
strsplit(y,"")[[:]][1]
strsplit(y,"")[][1]
strsplit(y,"")[][2]
strsplit(y,"")[][,]
strsplit(y,"")[][]
strsplit(y,"")
unique(strsplit(y,"")[][])
uniqchars <- function(x)
{
x <- gsub("[^[:alnum:]]", "", x)
print (class(x))
lengths_unique <- lapply(x, length(unique(strsplit(x,"")[[1]])))
return (lengths_unique)
}
v
uniqchars(v)
uniqchars <- function(x)
{
x <- gsub("[^[:alnum:]]", "", x)
print (class(x))
#  lengths_unique <- lapply(x, length(unique(strsplit(x,"")[[1]])))
return ( length(unique(strsplit(x,"")[[1]])))
}
uniqchars(x)
x
lapply(v, uniqchars)
uniqchars <- function(x)
{
x <- gsub("[^[:alnum:]]", "", x)
#print (class(x))
#  lengths_unique <- lapply(x, length(unique(strsplit(x,"")[[1]])))
return ( length(unique(strsplit(x,"")[[1]])))
}
lapply(v, uniqchars)
r <- lapply(v, uniqchars)
r[1]
r[2]
r[1]+9
r
r[[1]][1]
r[[1]][1]+8
r[[2]][1]+8
uniqchars <- function(x)
{
x <- gsub("[^[:alnum:]]", "", x)
#print (class(x))
#  lengths_unique <- lapply(x, length(unique(strsplit(x,"")[[1]])))
return ( length(unique(strsplit(x,"")[[1]])))[[]][1]
}
uniqchars(v)
uniqchars <- function(x)
{
x <- gsub("[^[:alnum:]]", "", x)
#print (class(x))
#  lengths_unique <- lapply(x, length(unique(strsplit(x,"")[[1]])))
return ( length(unique(strsplit(x,"")[[1]])))[[]]
}
uniqchars(v)
uniqchars <- function(x)
{
x <- gsub("[^[:alnum:]]", "", x)
#print (class(x))
#  lengths_unique <- lapply(x, length(unique(strsplit(x,"")[[1]])))
return ( length(unique(strsplit(x,"")[[1]])))
}
uniqchars(v)
uniqchars <- function(x)
{
x <- gsub("[^[:alnum:]]", "", x)
#print (class(x))
#  lengths_unique <- lapply(x, length(unique(strsplit(x,"")[[1]])))
return ( length(unique(strsplit(x,"")[[1]])))
}
v
uniqchars(v)
r <- lapply(v, uniqchars)
r
unlist(r)
installed.packages(c("UsingR","statsr","tidyverse","dslabs"))
install.packages("statsr")
install.packages(c("UsingR","statsr","tidyverse","dslabs"))
install.packages("ppml")
?dnorm
dnorm(0, mean = 0, sd = 1, log = FALSE)
dnorm(2, mean = 0, sd = 1, log = FALSE)
dnorm(c(0,0), mean = 0, sd = 1, log = FALSE)
dnorm(c(0,2), mean = 0, sd = 1, log = FALSE)
install.packages("stranger")
install.packages("IsolationForest")
install.packages("IsolationForest", repos="<a class="vglnk" href="http://R-Forge.R-project.org" rel="nofollow"><span>http</span><span>://</span><span>R</span><span>-</span><span>Forge</span><span>.</span><span>R</span><span>-</span><span>project</span><span>.</span><span>org</span></a>")
install.packages("IsolationForest", repos="<a class="vglnk" href="http://R-Forge.R-project.org" rel="nofollow"><span>http</span><span>://</span><span>R</span><span>-</span><span>Forge</span><span>.</span><span>R</span><span>-</span><span>project</span><span>.</span><span>org</span></a>")
install.packages("iForest")
install.packages("IForest")
#' @include util.R
## put splitting function in its own function
split_on_var <- function(x, ...) UseMethod("split_on_var")
#' importFrom stats runif
split_on_var.numeric <- function(x, ...) {
v = do.call(runif, as.list(c(1, range(x))))
list(value = v, filter = x < v)
}
## sample the levels from this partition and map them back to the full levels
split_on_var.factor <- function(x, ..., idx=integer(32)) {
l = which(levels(x) %in% unique(x)) ## which observed levels are present?
if (length(l) < 1) print("zero length!?")
## don't sample 0 or all
#s = sample(2^(length(l)) - 1, 1)
s = sample(max(1, 2^(length(l)) - 2), 1)
i = l[which(intToBits(s) == 1)]
idx[i] = 1L
list(value = packBits(idx, type="integer"), filter = x %in% levels(x)[i])
}
## pull the recursive function out
# X = data, e = current depth, l = max depth, ni = node index
recurse <- function(idx, e, l, ni=0, env, sentinel) {
## don't sample columns with all dups
dups <- sapply(env$X[idx,], function(x) all(duplicated(x)[-1L]))
## Base case
if (e >= l || length(idx) <= 1 || all(dups)) {
#if (e >= l || length(idx) <= 1) {
env$mat[ni,c("Type", "Size")] <- c(-1, length(idx))
return()
}
## randomly select attribute
#i = sample(1:NCOL(env$X), 1)
if (identical(sum(!dups), 1L)) {
i <- which(!dups)
} else {
i <- sample(which(!dups), 1)
}
## check if factor with <= 32 levels
res = split_on_var(env$X[idx, i, TRUE])
f = res$filter
## modify matrix in place
env$mat[ni, c("Left")] <- nL <- 2 * ni
env$mat[ni, c("Right")] <- nR <- 2 * ni + 1
env$mat[ni, c("SplitAtt", "SplitValue", "Type")] <- c(i, res$value, 1)
env$mat[ni, "AttType"] <- ifelse(is.factor(env$X[,i,T]), 2, 1)
## recurse
recurse(idx[which(f)] , e + 1, l, nL, env, sentinel)
recurse(idx[which(!f)], e + 1, l, nR, env, sentinel)
}
## lots of allocated matrix space goes unused because max_nodes is an upper bound
## on how large the tree can be. This function subsets to only the rows needed
## for prediction
compress_matrix <- function(m) {
m = cbind(seq.int(nrow(m)), m)[m[,"Type"] != 0,,drop=FALSE]
m[,"Left"] = match(m[,"Left"], m[,1], nomatch = 0)
m[,"Right"] = match(m[,"Right"], m[,1], nomatch = 0)
m[m[,"Type"] == -1,"TerminalID"] = seq.int(sum(m[,"Type"] == -1))
m[,-1,drop=FALSE]
}
iTree <- function(X, l) {
env = new.env() ## pass everything in this environment to avoid copies
env$mat = matrix(0,
nrow = max_nodes(l),
ncol = 8,
dimnames = list(NULL, c("TerminalID", "Type","Size","Left","Right","SplitAtt","SplitValue","AttType")))
env$X = X
recurse(seq.int(nrow(X)), e=0, l=l, ni=1, env)
compress_matrix(env$mat)
}
#' @title iForest
#'
#' @description Build an Isolation Forest of completely random trees
#'
#' @param X a matrix or data.frame of numeric or factors values
#' @param nt the number of trees in the ensemble
#' @param phi the number of samples to draw without replacement to construct each tree
#' @param seed random seed to ensure creation of reproducible foresets
#' @param mulicore fit trees using the parallel package
#' @param replace_missing if TRUE, replaces missing factor levels with "." and missing
#' numeric values with the \code{sentinel} argument
#' @param sentinel value to use as stand-in for missing numeric values
#' @param ncolsample if not NULL, the default, `ncolsample` features are subsampled for each
#' tree. See details for more information.
#' @details An Isolation Forest is an unsupervised anomaly detection algorithm. The requested
#' number of trees, \code{nt}, are built completely at random on a subsample of size \code{phi}.
#' At each node a random variable is selected. A random split is chosen from the range of that
#' variable. A random sample of factor levels are chosen in the case the variable is a factor.
#'
#' Records from \code{X} are then filtered based on the split criterion and the tree building
#' begins again on the left and right subsets of the data. Tree building terminates when the
#' maximum depth of the tree is reached or there are 1 or fewer observations in the filtered
#' subset.
#'
#' If \code{ncolsample} is not null, the algorithm will subsample a number of features equal
#' to \code{ncolsample} to construct each tree. The features are not sampled randomly, but use
#' an appropriate measure for the column's class. This measure is first applied to all columns.
#' The decreasing order is then calculated and the first \code{ncolsample} columns are taken
#' from this ordering. Numeric fields are ordered using kurtosis while factors use Shannon
#' entropy.
#'
#' @return an \code{iForest} object
#' @references F. T. Liu, K. M. Ting, Z.-H. Zhou, "Isolation-based anomaly detection",
#' \emph{ACM Trans. Knowl. Discov. Data}, vol. 6, no. 1, pp. 3:1-3:39, Mar. 2012.
#'
#' @importFrom parallel detectCores makeCluster parLapply stopCluster
#' @export
iForest <- function(X, nt=100, phi=256, seed=1234, multicore=FALSE,
replace_missing=TRUE, sentinel=-9999999999, ncolsample=NULL) {
set.seed(seed)
l = ceiling(log(phi, 2))
if (!is.data.frame(X)) X <- as.data.frame(X)
## impute missing values
if (replace_missing) {
for (i in seq_along(X)) {
if (is.numeric(X[[i]])) {
X[[i]][is.na(X[[i]])] <- sentinel
} else if (is.factor(X[[i]])) {
levels(X[[i]]) <- c(levels(X[[i]]), ".")
X[[i]][is.na(X[[i]])] <- "."
}
}
}
# Check that no single factor has > 32 levels
factor32 <- sapply(X, function(x) class(x) == "factor" & nlevels(x) > 32)
if(sum(factor32) > 0) stop("Can not handle categorical predictors with more than 32 categories.")
## check for missing values
na.cols <- sapply(X, function(col) any(is.na(col)))
if (any(na.cols)) stop("Missing values found in: ", paste0(names(X[na.cols]), collapse = ", "))
## check ncolsample is valid
if (!is.null(ncolsample)) {
if (!is.numeric(ncolsample) || ncolsample < 0) stop("Invalid value for ncolsample.")
if (ncolsample >= ncol(X)) {
ncolsample <- NULL
warning("ncolsample >= ncol(X) resulting in no subsampling.")
}
}
if (multicore) {
ncores <- detectCores()
## subsample columns here
sample_dfs <- vector("list", nt)
for (i in seq_along(sample_dfs)) {
idx <- sample(nrow(X), phi)
sample_dfs[[i]] <- X[idx,]
if (!is.null(ncolsample)) {
cols <- sample_cols_(sample_dfs[[i]], sentinel)
## set non-sampled cols to all NA which will be skipped for tree construction
## yet still maintaing the correct column IDs which the is necessary for
## the internal tree representation
sample_dfs[[i]][,-head(cols, ncolsample)] <- NA
}
}
cl <- makeCluster(getOption("cl.cores", ncores))
on.exit(stopCluster(cl))
forest <- parLapply(cl, sample_dfs, iTree, l)
} else {
forest <- vector("list", nt)
for (i in 1:nt) {
s <- sample(nrow(X), phi)
Xs <- X[s,]
if (!is.null(ncolsample)) {
cols <- sample_cols_(Xs, sentinel)
Xs[,-head(cols, ncolsample)] <- NA
}
forest[[i]] <- iTree(Xs, l)
}
}
structure(
list(
forest  = forest,
phi     = as.integer(phi),
l       = l,
nTrees  = as.integer(nt),
nVars   = NCOL(X),
nTerm   = sapply(forest, function(t) max(t[,"TerminalID"])),
vNames  = colnames(X),
vLevels = sapply(X, levels)),
class = "iForest")
}
#' @export
print.iForest <- function(x, ...) {
txt = sprintf("Isolation Forest with %d Trees and Max Depth of %d", x$nTrees, x$l)
cat(txt)
}
?iForest
install.packages("devtools")
library(devtools)
install.packages("httr")
install.packages("openssl")
library(httr)
apt-get install libssl-dev/unstable
install.packages("openssl")
install.packages("devtools")
library(devtools)
install_github("Zelazny7/isofor")
library(isofor)
?isofor_to_sas
?isofor
library(isofor)
install.packages('anomalize')
library(anomalize)
?amolize
?anomalize
load("/home/zaid/Documents/Personal/Pak.ai/Data_Analytics_Cerification_training/Session_6/case_study/data1.RData")
View(data)
View(data)1
View(data1)
X = data1$X
View(X)
X%>%ggplot(aes(x=`Latency (ms)`,y=`Throughput (mb/s)`))+
geom_point(color='blue')
library(dplyr)
library(ggplot2)
X%>%ggplot(aes(x=`Latency (ms)`,y=`Throughput (mb/s)`))+
geom_point(color='blue')
X = as.data.frame(X)
X%>%ggplot(aes(x=`Latency (ms)`,y=`Throughput (mb/s)`))+
geom_point(color='blue')
X%>%ggplot(aes(x=`V1`,y=`V2`))+
geom_point(color='blue')
X <- data1$X
X=as.data.frame(X)
names(X)=c("Latency (ms)", "Throughput (mb/s)")
X%>%ggplot(aes(x=`Latency (ms)`,y=`Throughput (mb/s)`))+
geom_point(color='blue')
XX=melt(X)
library(dplyr)
library(ggplot2)
library(isofor)
X%>%ggplot(aes(x=`Latency (ms)`,y=`Throughput (mb/s)`))+
geom_point(color='blue')
XX=melt(X)
library(tidyverse)
library(tidyr)
XX=melt(X)
library(reshape)
library(reshape2)
XX=melt(X)
View(X)
View(XX)
XX%>%ggplot(aes(x=value,fill=variable, color=variable))+
geom_density(alpha = 0.3)+ggtitle('Distibution of X')
p%>%ggplot(aes(y=probability,x=1))+geom_boxplot()+
geom_jitter()+xlab('')+ggtitle("Box plot of calculate probabilities")
model <- iForest(X)
model$vNames
model$forest
model$nTrees
model$nTerm
n <- predict(model,X)
View(n)
max(n)
summary(n)
hist(n)
which(n > 0.6)
summary(X$`Latency (ms)`)
summary(X$`Throughput (mb/s)`)
setwd("~/Documents/Personal/Pak.ai/Data_Analytics_Cerification_training/Session_6")
